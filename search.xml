<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis-介绍</title>
      <link href="/2022/05/09/Redis-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/05/09/Redis-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是Redis？"><a href="#1-什么是Redis？" class="headerlink" title="1.什么是Redis？"></a>1.什么是Redis？</h2><p><code>Redis</code>又称远程字典服务，是一个key-value数据库，通过将数据缓存在内存中，提高效率。</p><p><strong>优点</strong>：</p><ul><li>读写性能极高，<code>Redis</code>读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。</li><li>支持数据持久化，支持<code>AOF</code>和<code>RDB</code>两种持久化方式。</li><li>支持事务， <code>Redis</code>的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过<code>MULTI</code>和<code>EXEC</code>指令包起来。</li><li>数据结构丰富，除了支持string类型的value外，还支持hash、set、zset、list等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li><li>丰富的特性 – <code>Redis</code>还支持 <code>publish/subscribe</code>、通知、key 过期等特性。</li></ul><p><strong>缺点</strong>：</p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li></ul><h2 id="2-Redis速度为什么快？"><a href="#2-Redis速度为什么快？" class="headerlink" title="2.Redis速度为什么快？"></a>2.Redis速度为什么快？</h2><ul><li><p><strong>内存存储</strong>：<code>Redis</code>是使用内存存储，没有磁盘IO上的开销。数据存在内存中，类似于 <code>HashMap</code>，<code>HashMap</code> 的优势就是查找和操作的时间复杂度都是O(1)。</p></li><li><p><strong>单线程实现</strong>（ Redis 6.0以前）：<code>Redis</code>使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。</p></li><li><p><strong>非阻塞IO</strong>：<code>Redis</code>使用多路复用IO技术，将<code>epoll</code>作为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将<code>epoll</code>中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间。</p></li><li><p><strong>优化的数据结构</strong>：<code>Redis</code>有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。</p></li><li><p><strong>使用底层模型不同</strong>：<code>Redis</code>直接自己构建了虚拟内存<code>VM </code>机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p></li></ul><blockquote><p><code>Redis</code>的虚拟内存<code>VM</code>机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过<code>VM</code>功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。</p><p><code>Redis</code>提高数据库容量的办法有两种：一种是可以将数据分割到多个<code>Redis</code>服务器上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。<strong>需要特别注意的是Redis并没有使用OS提供的Swap，而是自己实现。</strong></p></blockquote><h2 id="3-Redis相比Memcached有哪些优势？"><a href="#3-Redis相比Memcached有哪些优势？" class="headerlink" title="3. Redis相比Memcached有哪些优势？"></a>3. Redis相比Memcached有哪些优势？</h2><ul><li><p><strong>数据类型</strong>：<code>Memcached</code>所有的值均是简单的字符串，<code>Redis</code>支持更为丰富的数据类型，支持String(字符串)，List(列表)，Set(集合)、ZSet(有序集合)、Hash(哈希)等。</p></li><li><p><strong>持久化</strong>：<code>Redis</code>支持数据持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 <code>Memcached</code>不支持数据持久存储。</p></li><li><p><strong>集群模式</strong>：<code>Redis</code>提供主从同步机制，以及集群部署能力，能够提供高可用服务。<code>Memcached</code>没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p></li><li><p><strong>网络IO模型</strong>：<code>Redis</code>使用单线程的多路 IO 复用模型，<code>Memcached</code>使用多线程的非阻塞IO模式。</p></li><li><p>Redis支持服务器端的数据操作：<code>Redis</code>相比<code>Memcached</code>来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在<code>Memcached</code>里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在<code>Redis</code>中，这些复杂的操作通常和一般的GET&#x2F;SET一样高效。</p></li></ul><h2 id="4-为什么要用-Redis-做缓存？"><a href="#4-为什么要用-Redis-做缓存？" class="headerlink" title="4. 为什么要用 Redis 做缓存？"></a>4. 为什么要用 Redis 做缓存？</h2><p>1、<strong>从高并发上来说：</strong></p><p>​直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p>2、<strong>从高性能上来说：</strong></p><p>​用户第一次访问数据库中的某些数据。 因为是从硬盘上读取的所以这个过程会比较慢。将该用户访问的数据存在缓存中，下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据。</p><h2 id="5-Redis的数据类型"><a href="#5-Redis的数据类型" class="headerlink" title="5.Redis的数据类型"></a>5.Redis的数据类型</h2><ol><li><p><code>string</code>：每个字符串都是simple dynamic string，采用预分配冗余空间的方式来减少内存的频繁分配。SDS由三个部分组成：<code>free</code>:还剩多少空间 ;<code>len</code>:字符串长度 ;<code>buf</code>:存放的字符数组 </p></li><li><p><code>list</code>：简单的字符串列表(单键多值)，按照插入顺序排序，实际是个双向链表。</p><ul><li>List在元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist(压缩列表)；当数据量较多时使用quicklist(链表+压缩列表)，这样既满足了快速插入删除性能，又能避免出现太大的空间冗余。</li><li>压缩列表(ziplist)：所有元素紧挨存储在一起，分配的是一块连续的内存，用于<strong>存储小整数值，或者长度比较短的字符串</strong>。可以双向遍历(在数据结构中保存到最后一个元素的偏移量)，每个元素的长度不一定都相等。</li></ul></li><li><p><code>set</code>：对外提供的功能与list类似，也是一个列表，但提供自动去重的功能。</p><ul><li>底层数据结构：<ul><li>intset(可以理解为数组)：元素个数不少于512；元素可以用整形表示。查询方式用二分查找。</li><li>dict：key为set中元素的值，而value为null。</li></ul></li></ul></li><li><p><code>hash</code>：是一个键值对集合，类似于Java中的Map&lt;String, Object&gt;</p><ul><li>数据结构：<ul><li>ziplist(压缩列表)：hash对象保存的键和值字符串长度都小于64字节；hash对象保存的键值对数量小于512。</li><li>dict：由hashtable组成，可以动态扩容、缩容。</li></ul></li><li><strong>hash扩容、缩容</strong>：通过<code>ht</code>(包含了两个项的数组)和<code>rehashindex</code>(表示rehash目前的进度，如果没有进行rehash，则为-1)，目的是为了让hash负载因子维持在一个合理的范围。<ul><li>rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。避免庞大的计算量导致服务器在一段时间内停止服务。<strong>渐进式rehash</strong>过程如下：1、为ht[1]分配空间，并将rehashindex的值设置为0，表示rehash工作正式开始；2、在rehash期间，每次对字典执行增删改查操作，除了执行指定的操作以外，还会顺带将ht[0]在rehashindex索引下的所有键值对rehash到ht[1]，当前rehash过程结束后，将rehashindex+1；3、随着字典操作的不断进行，最终在某个时间点，ht[0]上的所有键值对都被rehash到ht[1]，这时将rehashindex设置为-1，表示rehash整个过程完成。</li><li><strong>注：</strong>在渐进式rehash的过程中，字典会同时使用ht[0]、ht[1]两个哈希表。在查找过程中，先在ht[0]上进行，如果没有找到再去ht[1]上进行；添加过程一律保存到ht[1]上，保证ht[0]包含的键值对只会减少不会增加。</li></ul></li></ul></li><li><p><code>zset</code>：有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。（zset可以用于构建<strong>延时队列</strong>）</p><ul><li><p>数据结构：</p><ul><li>ziplist(压缩列表)：hash对象保存的键和值字符串长度都小于64字节；hash对象保存的键值对数量小于128。<br><strong>存储方式</strong>：每个集合元素使用两个相邻的压缩列表节点存储                                                                                                                                              ，一个保存元素的成员，一个保存元素的分值。</li><li>dict+跳跃表<br><strong>存储方式</strong>：<strong>dict存储元素key和value，用于关联value和score；跳跃表：节点包含*obj指针指向key，用于给元素value排序</strong>，比有序链表效率高。redis的索引被提取为多层，所有的元素都会在L0层的链表中，根据分数对value进行排序，同时有一部分节点有机会被抽取到L1层，作为一个稀疏链表。同时L1层的一部分节点也有机会被抽取到L2层中，组成一个更稀疏的索引链表。从最高等级向低等级查询，类似于二分查找。</li></ul></li><li><p>应用：score存储时间戳。生产者生产消息时，用当前时间戳加上延时的时间戳；消费者拉取消息的时候，截取zset满足当前时间的数据，消费完移除消息。</p></li></ul></li></ol><p><strong>三种特殊的数据类型</strong>：</p><ol><li><code>Bitmap</code>：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmap中叫做偏移量。使用Bitmap实现统计功能，更省空间。如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。</li><li><code>Hyperloglog</code>：HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。场景：统计网页的UV（即Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</li><li><code>Geospatial</code>：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。</li></ol><h2 id="6-Redis的常用场景有哪些"><a href="#6-Redis的常用场景有哪些" class="headerlink" title="6. Redis的常用场景有哪些?"></a>6. Redis的常用场景有哪些?</h2><p><strong>1、缓存</strong></p><p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。<code>Redis</code>提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在<code>Redis</code>用在缓存的场合非常多。</p><p><strong>2、排行榜</strong></p><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。<code>Redis</code>提供的有序集合<code>zset</code>数据类构能实现各种复杂的排行榜应用。</p><p><strong>3、计数器</strong></p><p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。<code>Redis</code>提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p><p><strong>4、分布式会话</strong></p><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以<code>Redis</code>等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p><p><strong>5、分布式锁</strong></p><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用<code>Redis</code>的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p><p><strong>6、 社交网络</strong></p><p>点赞、踩、关注&#x2F;被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希<code>hash</code>、集合<code>set</code>等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过Redis的set能够很方便得出。</p><p><strong>7、最新列表</strong></p><p>Redis列表结构<code>list</code>，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p><p><strong>8、消息系统</strong></p><p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布&#x2F;订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-锁</title>
      <link href="/2022/05/09/MySQL-%E9%94%81/"/>
      <url>/2022/05/09/MySQL-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL-锁"></a>MySQL-锁</h1><h2 id="1-为什么要加锁？"><a href="#1-为什么要加锁？" class="headerlink" title="1.为什么要加锁？"></a>1.为什么要加锁？</h2><p>当多个用户并发地存取数据时，在数据库中就可能出现多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。所以数据库加锁是为了<strong>保证多用户环境下保证数据库完整性和一致性。</strong></p><h2 id="2-数据库锁都有哪些？"><a href="#2-数据库锁都有哪些？" class="headerlink" title="2.数据库锁都有哪些？"></a>2.数据库锁都有哪些？</h2><h3 id="1-按照锁的粒度"><a href="#1-按照锁的粒度" class="headerlink" title="1.按照锁的粒度"></a>1.按照锁的粒度</h3><p>对数据操作的粒度大小</p><p><strong>行级锁</strong></p><ul><li>行级锁是<code>MySQL</code>中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。</li><li>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ul><p><strong>表级锁</strong></p><ul><li>表级锁是<code>MySQL</code>中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分<code>MySQL</code>引擎支持。最常使用的<code>MYISAM</code>与<code>INNODB</code>都支持表级锁定。</li><li>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li></ul><p><strong>页级锁</strong></p><ul><li>页级锁是<code>MySQL</code>中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<code>BDB</code>支持页级锁。</li><li>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p><ul><li><code>MyISAM</code>采用表级锁(table-level locking)。</li><li><code>InnoDB</code>支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><h3 id="2-按照锁的类别"><a href="#2-按照锁的类别" class="headerlink" title="2.按照锁的类别"></a>2.按照锁的类别</h3><ul><li><p>共享锁：又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p></li><li><p>排他锁：又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p></li></ul><h2 id="3-数据库的乐观锁和悲观锁"><a href="#3-数据库的乐观锁和悲观锁" class="headerlink" title="3.数据库的乐观锁和悲观锁"></a>3.数据库的乐观锁和悲观锁</h2><p>数据库管理系统<code>DBMS</code>中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><ol><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。<ul><li>适合写多读少的场景。</li></ul></li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过<code>version</code>的方式来进行锁定。实现方式：<code>version</code>版本字段或者<code>timestamp</code>时间戳字段机制+<code>CAS</code>算法实现。<ul><li>适合读多写少的场景。</li></ul></li></ol><h2 id="4-InnoDB引擎的行锁是怎么实现的？"><a href="#4-InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="4.InnoDB引擎的行锁是怎么实现的？"></a>4.InnoDB引擎的行锁是怎么实现的？</h2><p><code>InnoDB</code>是基于索引来完成行锁例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tab_with_index <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre><p><code>for update</code> 可以根据条件来完成行锁锁定，并且<code>id</code>是有索引键的列，如果 <code>id </code>不是索引键那么<code>InnoDB</code>将完成表锁，并发将无从谈起。</p><h2 id="5-什么是死锁？怎么解决？"><a href="#5-什么是死锁？怎么解决？" class="headerlink" title="5. 什么是死锁？怎么解决？"></a>5. 什么是死锁？怎么解决？</h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。死锁的关键在于：<strong>两个(或以上)的事务加锁的顺序不一致</strong>。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h2 id="6-隔离级别与锁的关系"><a href="#6-隔离级别与锁的关系" class="headerlink" title="6. 隔离级别与锁的关系"></a>6. 隔离级别与锁的关系</h2><ul><li>在<code>Read Uncommitted</code>级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li><li>在<code>Read Committed</code>级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li><li>在<code>Repeatable Read</code>级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li><li><code>SERIALIZABLE </code>是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li></ul><h2 id="7-优化锁方面的意见？"><a href="#7-优化锁方面的意见？" class="headerlink" title="7. 优化锁方面的意见？"></a>7. 优化锁方面的意见？</h2><ul><li>使用较低的隔离级别</li><li>设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突</li><li>选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。例如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁</li><li>不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。</li><li>尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li>数据查询的时候不是必要，不要使用加锁。<code>MySQL</code>的<code>MVCC</code>可以实现事务中的查询不用加锁，优化事务性能：<code>MVCC</code>只在<code>committed read</code>（读提交）和<code>repeatable read</code>（可重复读）两种隔离级别</li><li>对于特定的事务，可以使用表锁来提高处理速度以及减少死锁的可能。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-事务</title>
      <link href="/2022/05/05/MySQL-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/05/05/MySQL-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL事务及其特征"><a href="#MySQL事务及其特征" class="headerlink" title="MySQL事务及其特征"></a>MySQL事务及其特征</h2><ol><li><strong>事务</strong>是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li><li>事务的四个特征<ul><li>**原子性(Atomicity)**：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</li><li>**一致性(Consistency)**：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</li><li>**隔离性(Isolation)**：一个事务的执行不能被其它事务干扰。即一个事务内部的操作对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>**持续性(Durability)**：一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li></ul></li></ol><h2 id="MySQL四种隔离级别"><a href="#MySQL四种隔离级别" class="headerlink" title="MySQL四种隔离级别"></a>MySQL四种隔离级别</h2><ul><li><strong>脏读</strong>：一个事务读取另一个事务还未提交的数据。事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</li><li><strong>不可重复读</strong>：一个事务内多次读同一数据，在这个事务还没结束时，另一个事务修改该数据。事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li><strong>幻读</strong>：一个事务内多次读同一数据，在这个事务还没结束时，另一个事务插入了一些数据。这就导致事务前后查询出的记录数目不一致，就好像发生了幻觉一样，这就叫幻读。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol><li>Read Uncommitted（读未提交）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。</li><li>Read Committed（读已提交）：一个事务只能看见已经提交事务所做的改变。</li><li>Repeatable Read（可重复读）：它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这是 MySQL 的默认事务隔离级别。</li><li>Serializable（可串行化）：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li></ol><p><img src="http://blog-img.coolsen.cn/img/image-20210822180308501.png" alt="四种隔离级别"></p><p>MySQL 默认采用的 REPEATABLE_READ隔离级别， Oracle 默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读已提交)；但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p><h2 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h2><p>事务是基于重做日志(<code>redo log</code>)和回滚日志(<code>undo log</code>)实现的。</p><ul><li><code>redo log</code>：每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过<strong>重做日志来保证事务的原子性和持久性。</strong></li><li><code>undo log</code>：每当有修改事务时，会产生回滚日志，如果需要回滚，则根据回滚日志的反向语句进行逻辑操作。比如 insert 一条记录就产生一条delete记录。<strong>回滚日志主要实现数据库的一致性。</strong></li></ul><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p><code>redo log</code>在事务的执行过程中，便开始写入<code>redo log buffer</code>，接着刷盘到<code>redo log</code>文件里面 。硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p><blockquote><p>注：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p></blockquote><p><img src="http://blog-img.coolsen.cn/img/image-20210822181340692.png" alt="redo log"></p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><code>undo log</code> 用来回滚行记录到某个版本。事务未提交之前，回滚日志保存了未提交之前的版本数据，回滚日志中的数据可作为数据旧版本快照供其他并发事务进行快照读。在 MySQL innodb 存储引擎中用<code>undo log</code>实现多版本并发控制。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210822181416382.png" alt="undo log"></p><h2 id="MySQL的binlog"><a href="#MySQL的binlog" class="headerlink" title="MySQL的binlog"></a>MySQL的binlog</h2><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" alt="binlog"></p><p><code>binlog</code>(归档日志)是server层的，无论MySQL用什么引擎都会有的，主要是用作主从复制，时间点恢复。归档日志是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。归档日志不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但可以通过查询通用日志来查看 MySQL 执行过的所有语句。</p><h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><ul><li><p><strong>statement：</strong> 基于 SQL 语句的模式，某些语句和函数如<code>update_time=now()</code>在复制过程可能导致数据不一致甚至出错。</p></li><li><p><strong>row：</strong> 基于行的模式，记录的是行的变化，很安全。但是<code>binlog</code>会比其他两种模式大很多，在一些大表中清除大量数据时在<code>binlog</code>中会生成很多条语句，可能导致从库延迟变大。</p></li><li><p><strong>mixed：</strong> 混合模式，根据语句来选用是 statement 还是 row 模式。</p></li></ul><h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234747840.png" alt="binlog写入机制"></p><h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p><code>MVCC</code>， 即多版本并发控制。<code>MVCC</code> 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p><code>MVCC</code>实现：</p><ul><li><strong>隐藏字段</strong><ul><li><code>DB_TRX_ID</code>：表示最后一次插入或更新该行的事务 id。</li><li><code>DB_ROLL_PTR</code>：指向该行的 <code>undo log</code>。</li></ul></li><li><strong>Read View</strong>：主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”<br>创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（<code>Read View</code>），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。</li><li><strong>undo log</strong>：当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><p>在内部实现中，通过<code>DB_TRX_ID</code>和<code>Read View</code>来判断数据的可见性，如果不可见，则通过数据行的<code>DB_ROLL_PTR</code>找到<code>undo log</code>中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建<code>Read View</code>之前已经提交的数据和该事务中所做的修改。</p><p><img src="http://blog-img.coolsen.cn/img/modb_95751916-225c-11eb-b0bb-5254001c05fe.png" alt="mvcc原理"></p><p><code>MVCC</code> 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 <code>MVCC</code>，保证了事务 ACID 中的 I（隔离性）特性。</p><ol><li>快照读：读取的是记录的可见版本(可能是历史版本)，不用加锁<ul><li>在<code>RR</code> 和 <code>RC</code> 两个隔离级别下，简单的select操作，属于快照读</li><li>实现：通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</li></ul></li><li>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，避免其他事务并发修改这条记录。<ul><li>特殊的读操作，插入&#x2F;更新&#x2F;删除操作，属于当前读</li><li>加锁的情况：<br>1、<code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞。<br>2、<code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul></li></ol><p>结论：在MySQL&#x2F;InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p><h3 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h3><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 <code>RC</code> 隔离级别下的每次<code>select</code> 查询前都生成一个<code>Read View</code> (m_ids 列表)&#x3D;&#x3D;&gt;<strong>导致不可重复读</strong><br>RC隔离级别需要保持语句级别的一致性，开销较大</li><li>在 <code>RR</code> 隔离级别下只在事务开始后 第一次<code>select</code> 查询前生成一个<code>Read View</code>（m_ids 列表）<br>RR隔离级别获得的是事务级读—致性，消耗更少</li></ul><h3 id="InnoDB如何解决幻读"><a href="#InnoDB如何解决幻读" class="headerlink" title="InnoDB如何解决幻读"></a>InnoDB如何解决幻读</h3><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用<code>Next-key Lock </code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-基础</title>
      <link href="/2022/05/05/MySQL-%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/05/MySQL-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><ol><li><strong>第一范式</strong>：字段不可分；</li><li><strong>第二范式</strong>：有主键，非主键字段依赖主键。一个表只说明一个事务；</li><li><strong>第三范式</strong>：非主键字段不能相互依赖。每列都与主键有直接关系，不存在传递依赖。</li></ol><h2 id="MySQL支持的存储引擎"><a href="#MySQL支持的存储引擎" class="headerlink" title="MySQL支持的存储引擎"></a>MySQL支持的存储引擎</h2><p>MySQL 支持多种存储引擎，比如 InnoDB、MyISAM、Memory、Archive 等等。InnoDB 也是 MySQL 的默认存储引擎。</p><p><strong>MyIsam</strong>和<strong>InnoDB</strong>存储引擎区别</p><ol><li>InnoDB支持事务(因为undo log), MyISAM不支持</li><li>InnoDB支持行级锁， MyISAM支持表级锁</li><li>InnoDB支持多版本并发控制(<strong>MVVC</strong>)，MyISAM不支持</li><li>InnoDB支持外键，MyISAM不支持</li><li>MyISAM支持全文索引，InnoDB不支持</li><li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li></ol><h2 id="主键、超键、候选键、外键的关系"><a href="#主键、超键、候选键、外键的关系" class="headerlink" title="主键、超键、候选键、外键的关系"></a>主键、超键、候选键、外键的关系</h2><ol><li><p><strong>主键：</strong>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。<strong>一个数据列只能有一个主键</strong>，且主键的取值不能缺失，即不能为空值（Null）。</p></li><li><p><strong>超键：</strong>在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。<strong>超键包含候选键和主键</strong>。<br>e.g.</p><table><thead><tr><th>姓名(假设姓名不重复)</th><th>学号</th><th>年龄</th></tr></thead><tbody><tr><td>aaa</td><td>1</td><td>20</td></tr><tr><td>bbb</td><td>2</td><td>30</td></tr><tr><td>ccc</td><td>3</td><td>23</td></tr></tbody></table><p>姓名唯一，是个超键<br>学号唯一，是个超键<br>（姓名，年龄）唯一 ，是个超键<br>（学号，年龄）唯一，是个超键<br>姓名唯一，且没有其他多余属性，是个候选键</p></li><li><p><strong>候选键：</strong>它是<strong>最小超键</strong>，即没有冗余元素的超键。</p></li><li><p><strong>外 键：</strong>在一个表中存在的<strong>另一个表的主键</strong>称此表的外键。</p></li></ol><h2 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h2><ol><li><strong>NOT NULL:</strong> 用于控制字段的内容一定不能为空（NULL）。</li><li><strong>UNIQUE:</strong> 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li><strong>PRIMARY KEY:</strong> 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li><strong>FOREIGN KEY:</strong> 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li><strong>CHECK:</strong> 用于控制字段的值范围。</li></ol><h2 id="什么是存储过程？"><a href="#什么是存储过程？" class="headerlink" title="什么是存储过程？"></a>什么是存储过程？</h2><ul><li><strong>存储过程</strong>是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来调用存储过程。<strong>说白点</strong>，存储过程就是一段用于专门做一件事情的SQL语句。</li><li><strong>优点：</strong>存储过程是一个预编译的代码块，执行效率比较高 ，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全</li></ul><h2 id="MySQL-执行查询的过程"><a href="#MySQL-执行查询的过程" class="headerlink" title="MySQL 执行查询的过程"></a>MySQL 执行查询的过程</h2><ol><li>客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配。</li><li>查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）</li><li>语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。</li><li>优化。是否使用索引，生成执行计划。</li><li>交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</li></ol><p><img src="https://static001.geekbang.org/infoq/41/4102b7d60fa20a0caabb127ecbb4d2f3.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="MySQL查询流程"></p><h2 id="MySQL-中的-varchar-和-char-有什么区别？"><a href="#MySQL-中的-varchar-和-char-有什么区别？" class="headerlink" title="MySQL 中的 varchar 和 char 有什么区别？"></a>MySQL 中的 varchar 和 char 有什么区别？</h2><p><code>char</code> 是一个定长字段，假如申请了<code>char(10)</code>的空间，那么无论实际存储多少内容，该字段都占用 10 个字符；而 <code>varchar</code> 是变长的，也就是说申请的只是最大长度，占用的空间为实际字符长度+1。</p><p>在检索效率上来讲，char &gt; varchar，因此在使用中，如果确定某个字段的值的长度，可以使用 <code>char</code>；否则应该尽量使用 <code>varchar</code>。例如存储用户 MD5 加密后的密码，则应该使用<code> char</code>。</p><h2 id="MySQL中-in-和-exists-区别"><a href="#MySQL中-in-和-exists-区别" class="headerlink" title="MySQL中 in 和 exists 区别*"></a>MySQL中 in 和 exists 区别*</h2><ul><li>MySQL中的<code>in</code>语句先执行子查询，子查询的返回结果去重之后，再执行主查询。<code>in</code>查询在内部表和外部表上都可以使用到索引。当<strong>子查询结果集</strong>较小，而外部表很大的时候；</li><li>MySQL中的<code>exists</code>语句是对外表作loop循环，每次loop循环在关联内表进行查询。<code>exists</code>查询仅在内部表上可以使用到索引当<strong>子查询结果集</strong>很大，而外部表较小的时候，适合用<code>exists</code>。</li><li><code>not in </code>和<code>not exists</code>：如果查询语句使用了<code>not in</code>，那么内外表都进行全表扫描，没有用到索引；而<code>not exists</code>的<strong>子查询</strong>依然能用到表上的索引。所以无论那个表大，用<code>not exists</code>都比<code>not in</code>要快。</li></ul><h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>三者都表示删除，区别如下</p><table><thead><tr><th align="center"></th><th align="center">Delete</th><th align="center">Truncate</th><th align="center">Drop</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属于DML</td><td align="center">属于DDL</td><td align="center">属于DDL</td></tr><tr><td align="center">回滚</td><td align="center">可回滚</td><td align="center">不可回滚</td><td align="center">不可回滚</td></tr><tr><td align="center">删除内容</td><td align="center">表结构还在，删除表的部分或全部数据行</td><td align="center">表结构还在，删除表中的所有数据</td><td align="center">从数据库中删除整个表，连同数据、索引和权限</td></tr><tr><td align="center">删除速度</td><td align="center">删除速度慢，需要逐行删除</td><td align="center">删除速度快</td><td align="center">删除速度最快</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
