<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL-事务</title>
      <link href="/2022/05/05/MySQL-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/05/05/MySQL-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL事务及其特征"><a href="#MySQL事务及其特征" class="headerlink" title="MySQL事务及其特征"></a>MySQL事务及其特征</h2><ol><li><strong>事务</strong>是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li><li>事务的四个特征<ul><li>**原子性(Atomicity)**：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</li><li>**一致性(Consistency)**：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</li><li>**隔离性(Isolation)**：一个事务的执行不能被其它事务干扰。即一个事务内部的操作对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>**持续性(Durability)**：一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li></ul></li></ol><h2 id="MySQL四种隔离级别"><a href="#MySQL四种隔离级别" class="headerlink" title="MySQL四种隔离级别"></a>MySQL四种隔离级别</h2><ul><li><strong>脏读</strong>：一个事务读取另一个事务还未提交的数据。事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</li><li><strong>不可重复读</strong>：一个事务内多次读同一数据，在这个事务还没结束时，另一个事务修改该数据。事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li><strong>幻读</strong>：一个事务内多次读同一数据，在这个事务还没结束时，另一个事务插入了一些数据。这就导致事务前后查询出的记录数目不一致，就好像发生了幻觉一样，这就叫幻读。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol><li>Read Uncommitted（读未提交）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。</li><li>Read Committed（读已提交）：一个事务只能看见已经提交事务所做的改变。</li><li>Repeatable Read（可重复读）：它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这是 MySQL 的默认事务隔离级别。</li><li>Serializable（可串行化）：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li></ol><p><img src="http://blog-img.coolsen.cn/img/image-20210822180308501.png" alt="四种隔离级别"></p><p>MySQL 默认采用的 REPEATABLE_READ隔离级别， Oracle 默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读已提交)；但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p><h2 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h2><p>事务是基于重做日志(<code>redo log</code>)和回滚日志(<code>undo log</code>)实现的。</p><ul><li><code>redo log</code>：每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过<strong>重做日志来保证事务的原子性和持久性。</strong></li><li><code>undo log</code>：每当有修改事务时，会产生回滚日志，如果需要回滚，则根据回滚日志的反向语句进行逻辑操作。比如 insert 一条记录就产生一条delete记录。<strong>回滚日志主要实现数据库的一致性。</strong></li></ul><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p><code>redo log</code>在事务的执行过程中，便开始写入<code>redo log buffer</code>，接着刷盘到<code>redo log</code>文件里面 。硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p><blockquote><p>注：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p></blockquote><p><img src="http://blog-img.coolsen.cn/img/image-20210822181340692.png" alt="redo log"></p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><code>undo log</code> 用来回滚行记录到某个版本。事务未提交之前，回滚日志保存了未提交之前的版本数据，回滚日志中的数据可作为数据旧版本快照供其他并发事务进行快照读。在 MySQL innodb 存储引擎中用<code>undo log</code>实现多版本并发控制。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210822181416382.png" alt="undo log"></p><h2 id="MySQL的binlog"><a href="#MySQL的binlog" class="headerlink" title="MySQL的binlog"></a>MySQL的binlog</h2><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" alt="binlog"></p><p><code>binlog</code>(归档日志)是server层的，无论MySQL用什么引擎都会有的，主要是用作主从复制，时间点恢复。归档日志是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。归档日志不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但可以通过查询通用日志来查看 MySQL 执行过的所有语句。</p><h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><ul><li><p><strong>statement：</strong> 基于 SQL 语句的模式，某些语句和函数如<code>update_time=now()</code>在复制过程可能导致数据不一致甚至出错。</p></li><li><p><strong>row：</strong> 基于行的模式，记录的是行的变化，很安全。但是<code>binlog</code>会比其他两种模式大很多，在一些大表中清除大量数据时在<code>binlog</code>中会生成很多条语句，可能导致从库延迟变大。</p></li><li><p><strong>mixed：</strong> 混合模式，根据语句来选用是 statement 还是 row 模式。</p></li></ul><h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234747840.png" alt="binlog写入机制"></p><h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p><code>MVCC</code>， 即多版本并发控制。<code>MVCC</code> 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p><code>MVCC</code>实现：</p><ul><li><strong>隐藏字段</strong><ul><li><code>DB_TRX_ID</code>：表示最后一次插入或更新该行的事务 id。</li><li><code>DB_ROLL_PTR</code>：指向该行的 <code>undo log</code>。</li></ul></li><li><strong>Read View</strong>：主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”<br>创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（<code>Read View</code>），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。</li><li><strong>undo log</strong>：当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><p>在内部实现中，通过<code>DB_TRX_ID</code>和<code>Read View</code>来判断数据的可见性，如果不可见，则通过数据行的<code>DB_ROLL_PTR</code>找到<code>undo log</code>中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建<code>Read View</code>之前已经提交的数据和该事务中所做的修改。</p><p><img src="http://blog-img.coolsen.cn/img/modb_95751916-225c-11eb-b0bb-5254001c05fe.png" alt="mvcc原理"></p><p><code>MVCC</code> 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 <code>MVCC</code>，保证了事务 ACID 中的 I（隔离性）特性。</p><ol><li>快照读：读取的是记录的可见版本(可能是历史版本)，不用加锁<ul><li>在<code>RR</code> 和 <code>RC</code> 两个隔离级别下，简单的select操作，属于快照读</li><li>实现：通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</li></ul></li><li>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，避免其他事务并发修改这条记录。<ul><li>特殊的读操作，插入&#x2F;更新&#x2F;删除操作，属于当前读</li><li>加锁的情况：<br>1、<code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞。<br>2、<code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul></li></ol><p>结论：在MySQL&#x2F;InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p><h3 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h3><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 <code>RC</code> 隔离级别下的每次<code>select</code> 查询前都生成一个<code>Read View</code> (m_ids 列表)&#x3D;&#x3D;&gt;<strong>导致不可重复读</strong><br>RC隔离级别需要保持语句级别的一致性，开销较大</li><li>在 <code>RR</code> 隔离级别下只在事务开始后 第一次<code>select</code> 查询前生成一个<code>Read View</code>（m_ids 列表）<br>RR隔离级别获得的是事务级读—致性，消耗更少</li></ul><h3 id="InnoDB如何解决幻读"><a href="#InnoDB如何解决幻读" class="headerlink" title="InnoDB如何解决幻读"></a>InnoDB如何解决幻读</h3><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用<code>Next-key Lock </code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-基础</title>
      <link href="/2022/05/05/MySQL-%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/05/MySQL-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><ol><li><strong>第一范式</strong>：字段不可分；</li><li><strong>第二范式</strong>：有主键，非主键字段依赖主键。一个表只说明一个事务；</li><li><strong>第三范式</strong>：非主键字段不能相互依赖。每列都与主键有直接关系，不存在传递依赖。</li></ol><h2 id="MySQL支持的存储引擎"><a href="#MySQL支持的存储引擎" class="headerlink" title="MySQL支持的存储引擎"></a>MySQL支持的存储引擎</h2><p>MySQL 支持多种存储引擎，比如 InnoDB、MyISAM、Memory、Archive 等等。InnoDB 也是 MySQL 的默认存储引擎。</p><p><strong>MyIsam</strong>和<strong>InnoDB</strong>存储引擎区别</p><ol><li>InnoDB支持事务(因为undo log), MyISAM不支持</li><li>InnoDB支持行级锁， MyISAM支持表级锁</li><li>InnoDB支持多版本并发控制(<strong>MVVC</strong>)，MyISAM不支持</li><li>InnoDB支持外键，MyISAM不支持</li><li>MyISAM支持全文索引，InnoDB不支持</li><li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li></ol><h2 id="主键、超键、候选键、外键的关系"><a href="#主键、超键、候选键、外键的关系" class="headerlink" title="主键、超键、候选键、外键的关系"></a>主键、超键、候选键、外键的关系</h2><ol><li><p><strong>主键：</strong>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。<strong>一个数据列只能有一个主键</strong>，且主键的取值不能缺失，即不能为空值（Null）。</p></li><li><p><strong>超键：</strong>在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。<strong>超键包含候选键和主键</strong>。<br>e.g.</p><table><thead><tr><th>姓名(假设姓名不重复)</th><th>学号</th><th>年龄</th></tr></thead><tbody><tr><td>aaa</td><td>1</td><td>20</td></tr><tr><td>bbb</td><td>2</td><td>30</td></tr><tr><td>ccc</td><td>3</td><td>23</td></tr></tbody></table><p>姓名唯一，是个超键<br>学号唯一，是个超键<br>（姓名，年龄）唯一 ，是个超键<br>（学号，年龄）唯一，是个超键<br>姓名唯一，且没有其他多余属性，是个候选键</p></li><li><p><strong>候选键：</strong>它是<strong>最小超键</strong>，即没有冗余元素的超键。</p></li><li><p><strong>外 键：</strong>在一个表中存在的<strong>另一个表的主键</strong>称此表的外键。</p></li></ol><h2 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h2><ol><li><strong>NOT NULL:</strong> 用于控制字段的内容一定不能为空（NULL）。</li><li><strong>UNIQUE:</strong> 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li><strong>PRIMARY KEY:</strong> 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li><strong>FOREIGN KEY:</strong> 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li><strong>CHECK:</strong> 用于控制字段的值范围。</li></ol><h2 id="什么是存储过程？"><a href="#什么是存储过程？" class="headerlink" title="什么是存储过程？"></a>什么是存储过程？</h2><ul><li><strong>存储过程</strong>是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来调用存储过程。<strong>说白点</strong>，存储过程就是一段用于专门做一件事情的SQL语句。</li><li><strong>优点：</strong>存储过程是一个预编译的代码块，执行效率比较高 ，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全</li></ul><h2 id="MySQL-执行查询的过程"><a href="#MySQL-执行查询的过程" class="headerlink" title="MySQL 执行查询的过程"></a>MySQL 执行查询的过程</h2><ol><li>客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配。</li><li>查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）</li><li>语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。</li><li>优化。是否使用索引，生成执行计划。</li><li>交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</li></ol><p><img src="https://static001.geekbang.org/infoq/41/4102b7d60fa20a0caabb127ecbb4d2f3.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="MySQL查询流程"></p><h2 id="MySQL-中的-varchar-和-char-有什么区别？"><a href="#MySQL-中的-varchar-和-char-有什么区别？" class="headerlink" title="MySQL 中的 varchar 和 char 有什么区别？"></a>MySQL 中的 varchar 和 char 有什么区别？</h2><p><code>char</code> 是一个定长字段，假如申请了<code>char(10)</code>的空间，那么无论实际存储多少内容，该字段都占用 10 个字符；而 <code>varchar</code> 是变长的，也就是说申请的只是最大长度，占用的空间为实际字符长度+1。</p><p>在检索效率上来讲，char &gt; varchar，因此在使用中，如果确定某个字段的值的长度，可以使用 <code>char</code>；否则应该尽量使用 <code>varchar</code>。例如存储用户 MD5 加密后的密码，则应该使用<code> char</code>。</p><h2 id="MySQL中-in-和-exists-区别"><a href="#MySQL中-in-和-exists-区别" class="headerlink" title="MySQL中 in 和 exists 区别*"></a>MySQL中 in 和 exists 区别*</h2><ul><li>MySQL中的<code>in</code>语句先执行子查询，子查询的返回结果去重之后，再执行主查询。<code>in</code>查询在内部表和外部表上都可以使用到索引。当<strong>子查询结果集</strong>较小，而外部表很大的时候；</li><li>MySQL中的<code>exists</code>语句是对外表作loop循环，每次loop循环在关联内表进行查询。<code>exists</code>查询仅在内部表上可以使用到索引当<strong>子查询结果集</strong>很大，而外部表较小的时候，适合用<code>exists</code>。</li><li><code>not in </code>和<code>not exists</code>：如果查询语句使用了<code>not in</code>，那么内外表都进行全表扫描，没有用到索引；而<code>not exists</code>的<strong>子查询</strong>依然能用到表上的索引。所以无论那个表大，用<code>not exists</code>都比<code>not in</code>要快。</li></ul><h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>三者都表示删除，区别如下</p><table><thead><tr><th align="center"></th><th align="center">Delete</th><th align="center">Truncate</th><th align="center">Drop</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属于DML</td><td align="center">属于DDL</td><td align="center">属于DDL</td></tr><tr><td align="center">回滚</td><td align="center">可回滚</td><td align="center">不可回滚</td><td align="center">不可回滚</td></tr><tr><td align="center">删除内容</td><td align="center">表结构还在，删除表的部分或全部数据行</td><td align="center">表结构还在，删除表中的所有数据</td><td align="center">从数据库中删除整个表，连同数据、索引和权限</td></tr><tr><td align="center">删除速度</td><td align="center">删除速度慢，需要逐行删除</td><td align="center">删除速度快</td><td align="center">删除速度最快</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
